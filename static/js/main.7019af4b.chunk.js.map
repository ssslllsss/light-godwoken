{"version":3,"sources":["light-godwoken/constants/index.ts","light-godwoken/constants/tokens.ts","light-godwoken/godwoken/normalizer.ts","light-godwoken/constants/providerConfig.ts","light-godwoken/schemas/index.esm.js","light-godwoken/godwoken/godwoken.ts","light-godwoken/omni-lock/omni.js","light-godwoken/lightGodwokenProvider.ts","light-godwoken/constants/sudtErc20ProxyAbi.ts","light-godwoken/lightGodwoken.ts","contexts/LightGodwokenContext.tsx","hooks/useLightGodwoken.ts","utils/formatTokenAmount.ts","views/NumericalInput.tsx","views/CKBInputPanel.tsx","utils/getTimePeriods.ts","views/WithdrawalRequestCard.tsx","views/CurrencyInputPanel.tsx","components/Address/index.tsx","components/ConnectButton/index.tsx","views/PageHeader.tsx","views/Page.tsx","views/RequestWithdrawal.tsx","views/Withdrawal.tsx","hooks/useClock.ts","App.js","reportWebVitals.js","index.js"],"names":["SCRIPTS","script_type_hash","cell_dep","out_point","tx_hash","index","dep_type","code_hash","hash_type","short_id","ROLLUP_CONFIG","args","TOKEN_LIST","symbol","name","decimals","tokenURI","sudt_script_hash","address","issuerLockHash","l1Lock","normalizeHexNumber","length","debugPath","value","ArrayBuffer","intValue","BigInt","toString","Error","view","DataView","i","start","setUint8","parseInt","substr","buffer","byteLength","array","Uint8Array","set","normalizeRawData","Reader","toArrayBuffer","normalizeObject","obj","keys","result","key","f","Object","entries","undefined","toNormalize","normalize","NormalizeFee","fee","sudt_id","amount","NormalizeRawWithdrawalRequest","raw_request","nonce","capacity","account_script_hash","sell_amount","sell_capacity","owner_lock_hash","payment_lock_hash","PROVIDER_CONFIG","CKB_INDEXER_URL","CKB_RPC_URL","GW_POLYJUICE_RPC_URL","dataLengthError","actual","required","assertDataLength","assertArrayBuffer","reader","Function","serializeTable","buffers","itemCount","totalSize","offsets","push","setUint32","SerializeRawWithdrawalRequest","Uint32","size","Uint64","Uint128","Byte32","Fee","SerializeUint32","SerializeUint64","SerializeUint128","SerializeByte32","SerializeFee","SerializeWithdrawalRequest","raw","SerializeBytes","signature","SerializeDepositLockArgs","SerializeScript","layer2_lock","cancel_timeout","SerializeUnlockWithdrawalViaFinalize","constructor","validate","this","getSudtId","slice","getAmount","compatible","indexAt","getUint8","toBigEndianUint32","getUint32","toLittleEndianUint32","toBigEndianBigUint64","getBigUint64","toLittleEndianBigUint64","item","hashTypeView","GodwokenClient","url","rpc","RPC","method_name","request","data","NormalizeWithdrawalRequest","serializeJson","rpcCall","scriptHash","shortAddress","txHash","accountId","SerializeRcIdentity","SerializeIdentity","identity","map","maskView","mask","SerializeSmtProof","proof","SerializeSmtProofEntry","SerializeSmtProofEntryVec","proofs","SerializeRcLockWitnessLock","SerializeBytesOpt","SerializeRcIdentityOpt","rc_identity","preimage","POLYJUICE_CONFIG","web3Url","abiItems","inputs","internalType","type","stateMutability","anonymous","indexed","outputs","polyjuiceProvider","PolyjuiceHttpProvider","DefaultLightGodwokenProvider","ethAddress","ethereum","env","l2Address","l1Address","ckbIndexer","web3","godwokenClient","config","initializeConfig","predefined","AGGRON4","Indexer","LINA","generateL1Address","on","accounts","console","log","Web3","withdrawalRequest","submitWithdrawalRequest","getL2Address","getL1Address","isMetaMask","method","then","catch","error","code","omniLock","substring","helpers","generateAddress","tx","send_transaction","txSkeleton","message","generateMessage","signedMessage","params","selectedAddress","v","Number","padStart","signedWitness","toolkit","core","SerializeWitnessArgs","lock","update","witnesses","createTransactionFromSkeleton","hasher","utils","CKBHasher","rawTxHash","ckbHash","SerializeRawTransaction","normalizers","NormalizeRawTransaction","serializedWitness","repeat","hashWitness","digestHex","witness","lengthBuffer","setBigUint64","get_transaction","asyncSleep","getLastSubmittedInfo","transaction_hash","getPendingTransaction","rollupIndex","transaction","findIndex","o","computeScriptHash","queryOptions","collector","rollupCell","cell","collect","getRollupCell","globalState","godwokenCore","GlobalState","lastFinalizedBlockNumber","getLastFinalizedBlockNumber","ms","Promise","r","setTimeout","DefaultLightGodwoken","provider","payload","neededCapacity","neededSudtAmount","collectedCapatity","collectedSudtAmount","collectedCells","parseAddress","sudtType","cell_output","readBigUInt128LE","omniLockCellDep","secp256k1CellDep","outputCell","generateDepositOutputCell","TransactionSkeleton","cellProvider","cell_deps","sudtCellDep","signedTx","signL1Transaction","sendL1Transaction","ownerLock","depositLockArgs","toLowerCase","depositLockArgsHexString","NormalizeScript","NormalizeDepositLockArgs","depositLock","sumCapacity","reduce","acc","sumSustAmount","exchangeCell","toBigUInt128LE","getBlockProduceTime","outputCells","dummySudtCell","sudtCapacity","minimalCellCapacity","capacityLeft","newWitnessArgs","NormalizeWitnessArgs","withdrawalWitness","withdrawalLockDep","rollupCellDep","getRollupCellDep","injectCapacity","searchParams","getWithdrawalCellSearchParams","script","ownerCKBLock","ownerLockHash","rawLockArgs","lockArgs","WithdrawalLockArgs","withdrawBlock","getWithdrawalBlockNumber","containsOwnerLock","includes","erc20","sudtTypeHash","getBuiltinErc20List","find","e","withdrawalBlockNumber","remainingBlockNumber","Math","max","sortedWithdrawals","sort","a","b","startsWith","layer2Lock","accountScriptHash","script_type","withdrawWithEvent","eventEmitter","EventEmitter","withdraw","emit","rollupTypeHash","ethAccountTypeHash","withdrawal_address","l2AccountScript","fromId","getAccountIdByScriptHash","isSudt","minCapacity","minimalWithdrawalCapacity","getNonce","paymentLockHash","rawWithdrawalRequest","generateWithdrawalMessageToSign","signatureMetamaskPersonalSign","signMessageMetamaskPersonalSign","loop","nIntervId","setInterval","async","withdrawal","getWithdrawal","status","clearInterval","signMessage","privateKey","signObject","secp256k1","signatureBuffer","signatureArray","recid","serializedRawWithdrawalRequest","dummyHash","dummyHexNumber","dummyRollupTypeHash","dummyWithdrawalLockArgs","withdrawal_block_hash","withdrawal_block_number","serialized","SerializeWithdrawalLockArgs","withdrawal_lock_args","NormalizeWithdrawalLockArgs","balance","eth","getBalance","collectedSum","forEach","token","tokenL1Script","tokenScriptHash","getBuiltinL1TokenList","balances","promises","addresses","usdcBalancePromise","Contract","methods","balanceOf","call","all","values","types","fromScript","changeOutput","LightGodwokenContext","createContext","Provider","props","lightGodwoken","setLightGodwoken","useState","useEffect","detectEthereumProvider","instance","children","useLightGodwoken","useContext","getDisplayAmount","valueStr","intPart","unit","decPart","round","toFixed","replace","getFullDisplayAmount","options","maxDecimalPlace","StyledInput","styled","input","align","inputRegex","RegExp","Input","React","memo","onUserInput","placeholder","rest","onChange","event","nextUserInput","target","test","inputMode","title","autoComplete","autoCorrect","pattern","minLength","maxLength","spellCheck","StyleWrapper","div","Row","CKBInputPanel","label","showMaxButton","setShowMaxButton","l2CkbBalance","setL2CkbBalance","getL2CkbBalance","fetchData","className","Text","NumericalInput","val","onClick","src","alt","HOUR_IN_SECONDS","DAY_IN_SECONDS","MONTH_IN_SECONDS","YEAR_IN_SECONDS","getTimePeriods","seconds","delta","abs","timeLeft","years","months","days","hours","minutes","floor","Typography","PrimaryButton","Button","PlainButton","FixedHeightRow","UnlockModal","Modal","WithdrawalRequestCard","now","shouldShowMore","setShouldShowMore","blockProduceTime","setBlockProduceTime","isModalVisible","setIsModalVisible","isUnlocking","setIsUnlocking","handleToggleShowMore","useCallback","fetchBlockProduceTime","estimatedArrivalDate","useMemo","Date","estimatedSecondsLeft","isMature","daysLeft","hoursLeft","minutesLeft","secondsLeft","ckbAmount","ckbFullAmount","capacityBI","sudtAmount","sudtFullAmount","amountBI","handleCancel","UpOutlined","DownOutlined","visible","onOk","onCancel","footer","unlock","notification","success","window","open","loading","TokenList","TokenListModal","CurrencyInputPanel","autoFocus","disableInput","onSelectedChange","selectedCurrencyBalance","setCurrencyBalance","erc20List","setErc20List","balancesList","setBalancesList","selectedCurrency","setSelectedCurrency","selectedIndex","setSelectedIndex","results","addressList","getErc20Balances","currencyBalance","disabled","dataSource","renderItem","Item","handleErc20Selected","TipWrapper","truncateMiddle","str","first","last","Address","htmlFor","Group","compact","style","width","icon","CopyOutlined","ConnectButton","StyledPage","PageHeader","Page","PageContent","PageMain","WithDrawalButton","ConfirmModal","RequestWithdrawal","ckbInput","setCkbInput","outputValue","setOutputValue","setLoading","submitButtonDisable","setSubmitButtonDisable","selectedSudt","setSelectedSudt","to","ArrowLeftOutlined","QuestionCircleOutlined","PlusOutlined","pow","info","JSON","stringify","ResultList","Withdrawal","withdrawList","setWithdrawList","setTime","useClock","listWithdraw","fetchWithdrawList","App","path","element","reportWebVitals","onPerfEntry","import","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7019af4b.chunk.js","sourcesContent":["export const SCRIPTS = {\n  deposit_lock: {\n    script_type_hash: \"0x5a2506bb68d81a11dcadad4cb7eae62a17c43c619fe47ac8037bc8ce2dd90360\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x97614145cdec9ba924001c11cd49f1c424927437b40ed3ca3b82fff358f2e3de\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0x170ef156e9f6132dbca6069dfd3e436f7d91c29d3ac7332c4b33e633b6a299b5\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  eth_account_lock: {\n    script_type_hash: \"0xdeec13a7b8e100579541384ccaf4b5223733e4a5483c3aec95ddc4c1d5ea5b22\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x2f9f8ec8a1556238aeeefed29e990d53ea75060ef04249371fd8b5246fffb8ea\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n    code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n    hash_type: \"type\",\n    tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n};\nexport const ROLLUP_CONFIG = {\n  rollup_type_hash: \"0x4cc2e6526204ae6a2e8fcf12f7ad472f41a1606d5b9624beebd215d780809f6a\",\n  rollup_type_script: {\n    code_hash: \"0x5c365147bb6c40e817a2a53e0dec3661f7390cc77f0c02db138303177b12e9fb\",\n    hash_type: \"type\",\n    args: \"0x213743d13048e9f36728c547ab736023a7426e15a3d7d1c82f43ec3b5f266df2\",\n  },\n};\n","export const TOKEN_LIST = [\n  {\n    symbol: \"USDC\",\n    name: \"USD Coin\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xca6FcAAA5129aD9e5219397527A17c26E5AD6a6a\",\n    issuerLockHash: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    },\n  },\n  {\n    symbol: \"ETH\",\n    name: \"Ethereum\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/ethereum-eth-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xB1235Dd5bd72d9Ef2F0E311fC5ce7df0583B6458\",\n    issuerLockHash: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    },\n  },\n  {\n    symbol: \"TAI\",\n    name: \"NexisDAO TAI\",\n    decimals: 18,\n    tokenURI:\n      \"data:image/png;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAQDAwQDAwQEAwQFBAQFBgoHBgYGBg0JCggKDw0QEA8NDw4RExgUERIXEg4PFRwVFxkZGxsbEBQdHx0aHxgaGxr/2wBDAQQFBQYFBgwHBwwaEQ8RGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhr/wAARCAAoACgDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAgEBQYBCf/EADQQAAEDAwEEBwUJAAAAAAAAAAIAAQQDBRIGBxETURUhIjJCUmIWgYKisggUFyczNEFTZ//EABkBAAMBAQEAAAAAAAAAAAAAAAMFBgIEB//EACQRAAEEAgEDBQEAAAAAAAAAAAMAAQIEERIFEyHCFCIxMoKS/9oADAMBAAIRAxEAPwB85kwIdPI/c3NZyVc68ot+TgHJmVHtFmhV0xqApFSbTj04FdiKA2+QI8Msipevy+pKXC1zGgEIWXbHe7Mfhj6js9Qh+IxHFcsti7aSUtctkKTSH1Ti5Fv35OpsW5Vo795zDk6V32y2hjZBuhbRtAdBvW4PS2RfqY5YY445Y9rHJZGbrmNNMgvG2O93gvFH09ZzEfhPHH5ks9ObbaJP52l4oIpyD7op8YcsJdNiB+v+W5IWE2cy6Q6a08cc5px6lvoMJT/3BNgOL1fX5vUhbrXR2IPv8x7KpCRyQy6muzsT71An2O2XQSa5W+JMEv76An9SvLjGePJPyH1soqS2iyCSUVNtX6ctZJBgCgWzKJGKmBRvxSKjwsezjwy7KeqBYbZaxFrbbokPHu8CgIfSkJpVvy3hv/rZN8hL0HQebsSjGP68UyCHVdHvDihS7bQevIHyB1uhJqXHWLgurB8MmjCwr6ZDCVTcT9z8ln5FurR37ubc2QhW/KVBGC5JN3ZYmOMnylqD7L9YbBQs3T4vSpaz9pOL927WPDIeFj5t/iTLx7dWkP3cG5uhCj6zPylhh2HyzIg4sr6NFCIGFP3vzQhC9JEKAIMMbYZkRf/Z\",\n    sudt_script_hash: \"\",\n    address: \"0x8290f27935A2D353adc834c9F3c5F6ef19635C2D\",\n    issuerLockHash: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    },\n  },\n];\n","import { Hash, HexNumber, HexString, PackedSince, Script } from \"@ckb-lumos/lumos\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(args: object, { debugPath = \"deposit_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\n/**\n * sudt_id: uint32\n * amount: uint128\n */\nexport interface Fee {\n  sudt_id: HexNumber;\n  amount: HexNumber;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport function NormalizeRawWithdrawalRequest(raw_request: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(request: WithdrawalRequest, { debugPath = \"withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport function NormalizeWithdrawalLockArgs(\n  withdrawal_lock_args: WithdrawalLockArgs,\n  { debugPath = \"withdrawal_lock_args\" } = {},\n) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    account_script_hash: normalizeRawData(32),\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {},\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\n\nexport function NormalizeRawL2Transaction(\n  rawL2Transaction: RawL2Transaction,\n  { debugPath = \"raw_l2_transaction\" } = {},\n) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport function NormalizeL2Transaction(l2Transaction: L2Transaction, { debugPath = \"l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n","export const PROVIDER_CONFIG = {\n  LINA: {\n    //TODO: fake urls\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  AGGRON: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n};\n","/* eslint-disable */\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n    value.status,\n  );\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n    );\n  }\n\n  getVersion() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size(),\n    value.status,\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1,\n    value.version,\n  );\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n    }\n    new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer);\n  buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTxWitnessRoot() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxCount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevStateCheckpoint() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.tx_witness_root));\n  buffers.push(SerializeUint32(value.tx_count));\n  buffers.push(SerializeByte32(value.prev_state_checkpoint));\n  return serializeTable(buffers);\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getAmount() {\n    return new Uint128(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getFee() {\n    return new Fee(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Fee.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n    this.getNonce().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size()\n    );\n  }\n}\n\nexport function SerializeRawWithdrawalRequest(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.account_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeFee(value.fee)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequest(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getK() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getV() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.k));\n  buffers.push(SerializeByte32(value.v));\n  return serializeTable(buffers);\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  return serializeTable(value.map((item) => SerializeKVPair(item)));\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getAccountScriptHash().validate(compatible);\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"UnlockWithdrawalViaFinalize\";\n      case 1:\n        return \"UnlockWithdrawalViaRevert\";\n      case 2:\n        return \"UnlockWithdrawalViaTrade\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n    case \"UnlockWithdrawalViaFinalize\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaRevert\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaTrade\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalViaTrade {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getOwnerLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaTrade(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"CreateAccount\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n    case \"CreateAccount\": {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Fee {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSudtId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Fee.size());\n    this.getSudtId().validate(compatible);\n    this.getAmount().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint128.size();\n  }\n}\n\nexport function SerializeFee(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n  return array.buffer;\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeFee(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"SUDTQuery\";\n      case 1:\n        return \"SUDTTransfer\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n    case \"SUDTQuery\": {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SUDTTransfer\": {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortAddress() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_address));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint128(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(\n      this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class VerifyTransactionContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeVerifyTransactionContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeScriptVec(value.scripts));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalRequest() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"RollupSubmitBlock\";\n      case 1:\n        return \"RollupEnterChallenge\";\n      case 2:\n        return \"RollupCancelChallenge\";\n      case 3:\n        return \"RollupRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n    case \"RollupSubmitBlock\": {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupEnterChallenge\": {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupCancelChallenge\": {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupRevert\": {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianBigUint64() {\n    return this.view.getBigUint64(0, false);\n  }\n\n  toLittleEndianBigUint64() {\n    return this.view.getBigUint64(0, true);\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getExtraHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.extra_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexNumber, HexString } from \"@ckb-lumos/lumos\";\nimport { NormalizeWithdrawalRequest, WithdrawalRequest } from \"./normalizer\";\nimport { SerializeWithdrawalRequest } from \"../schemas/index.esm\";\n\ninterface LastL2BlockCommittedInfo {\n  transaction_hash: Hash;\n}\n/**\n * Godwoken RPC client\n */\nexport class GodwokenClient {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  /**\n   * Serialize withdrawal request and submit to godwoken\n   *\n   * @param request\n   * @returns\n   */\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  /**\n   *\n   * @param scriptHash layer2 lock script hash\n   * @returns uint32\n   */\n  async getAccountIdByScriptHash(scriptHash: Hash): Promise<HexNumber | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", scriptHash);\n    return id;\n  }\n\n  /**\n   *\n   * @param shortAddress scriptHash160 (scriptHash first 20 bytes)\n   * @returns uint32\n   */\n  async getScriptHashByShortAddress(shortAddress: HexString): Promise<Hash | undefined> {\n    const scriptHash = await this.rpcCall(\"get_script_hash_by_short_address\", shortAddress);\n    return scriptHash;\n  }\n  /**\n   *\n   * @param txHash Hash\n   * @returns uint32\n   */\n  async getWithdrawal(txHash: Hash): Promise<Hash | undefined> {\n    const withdrawal = await this.rpcCall(\"get_withdrawal\", txHash);\n    return withdrawal;\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns uint32 in hex number\n   */\n  async getNonce(accountId: HexNumber): Promise<HexNumber> {\n    const nonce = await this.rpcCall(\"get_nonce\", accountId);\n    return nonce;\n  }\n\n  async getLastSubmittedInfo(): Promise<LastL2BlockCommittedInfo> {\n    return await this.rpcCall(\"get_last_submitted_info\");\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns\n   */\n  async getScriptHash(accountId: HexNumber): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash\", accountId);\n  }\n}\n","/* eslint-disable */\n// Object.defineProperty(\n//   value: true\n// });\n\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n\n  const firstOffset = view.getUint32(4, true);\n\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n\n  const itemCount = firstOffset / 4 - 1;\n\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n\n  offsets.push(requiredByteLength);\n\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n  view.setUint32(0, totalSize, true);\n\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n\n  return buffer;\n}\n\nclass Identity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 21);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 21;\n  }\n}\n\nfunction SerializeIdentity(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 21);\n  return buffer;\n}\n\nclass RcIdentity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Identity(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProofEntryVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getIdentity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Identity(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProofs() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProofEntryVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRcIdentity(value) {\n  const buffers = [];\n  buffers.push(SerializeIdentity(value.identity));\n  buffers.push(SerializeSmtProofEntryVec(value.proofs));\n  return serializeTable(buffers);\n}\n\nclass RcIdentityOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new RcIdentity(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeRcIdentityOpt(value) {\n  if (value) {\n    return SerializeRcIdentity(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass RcLockWitnessLock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new RcIdentityOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getSignature() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getRcIdentity() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RcIdentityOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getPreimage() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nexport function SerializeRcLockWitnessLock(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.signature));\n  buffers.push(SerializeRcIdentityOpt(value.rc_identity));\n  buffers.push(SerializeBytesOpt(value.preimage));\n  return serializeTable(buffers);\n}\n\nclass ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nclass ScriptVecOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new ScriptVec(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptVecOpt(value) {\n  if (value) {\n    return SerializeScriptVec(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass XudtWitnessInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ScriptVecOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawExtensionData() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVecOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getExtensionData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtWitnessInput(value) {\n  const buffers = [];\n  buffers.push(SerializeScriptVecOpt(value.raw_extension_data));\n  buffers.push(SerializeBytesVec(value.extension_data));\n  return serializeTable(buffers);\n}\n\nclass RCRule {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSmtRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getFlags() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RCRule.size());\n    this.getSmtRoot().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeRCRule(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.smt_root)), 0);\n  view.setUint8(0 + Byte32.size(), value.flags);\n  return array.buffer;\n}\n\nclass RCCellVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeRCCellVec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass RCData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      case 1:\n        new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return \"RCRule\";\n\n      case 1:\n        return \"RCCellVec\";\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      case 1:\n        return new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nfunction SerializeRCData(value) {\n  switch (value.type) {\n    case \"RCRule\": {\n      const itemBuffer = SerializeRCRule(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    case \"RCCellVec\": {\n      const itemBuffer = SerializeRCCellVec(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nclass SmtProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtProof(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass SmtProofEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    if (offsets[1] - offsets[0] !== 1) {\n      throw new Error(`Invalid offset for mask: ${offsets[0]} - ${offsets[1]}`);\n    }\n\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getMask() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntry(value) {\n  const buffers = [];\n  const maskView = new DataView(new ArrayBuffer(1));\n  maskView.setUint8(0, value.mask);\n  buffers.push(maskView.buffer);\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass SmtProofEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new SmtProofEntry(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new SmtProofEntry(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntryVec(value) {\n  return serializeTable(value.map((item) => SerializeSmtProofEntry(item)));\n}\n\nclass SmtUpdateItem {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getKey() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getPackedValues() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SmtUpdateItem.size());\n    this.getKey().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeSmtUpdateItem(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.key)), 0);\n  view.setUint8(0 + Byte32.size(), value.packed_values);\n  return array.buffer;\n}\n\nclass SmtUpdateItemVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * SmtUpdateItem.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new SmtUpdateItem(this.view.buffer.slice(4 + i * SmtUpdateItem.size(), 4 + (i + 1) * SmtUpdateItem.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtUpdateItemVec(value) {\n  const array = new Uint8Array(4 + SmtUpdateItem.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeSmtUpdateItem(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * SmtUpdateItem.size());\n  }\n\n  return array.buffer;\n}\n\nclass SmtUpdateAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new SmtUpdateItemVec(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getUpdates() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SmtUpdateItemVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtUpdateAction(value) {\n  const buffers = [];\n  buffers.push(SerializeSmtUpdateItemVec(value.updates));\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass XudtData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtData(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.lock));\n  buffers.push(SerializeBytesVec(value.data));\n  return serializeTable(buffers);\n}\n\nclass Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nfunction SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nclass Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nfunction SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nclass Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nfunction SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nclass Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nclass Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nfunction SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nclass UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nclass TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Transaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nclass ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nclass Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nclass OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nfunction SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nclass CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nfunction SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nclass CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nclass CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nfunction SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nclass RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {\n      validate: false,\n    }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nclass Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nclass RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getUnclesHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getUnclesHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nfunction SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.uncles_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nclass Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {\n      validate: false,\n    });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nfunction SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nclass UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nclass WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { SCRIPTS } from \"./constants/index\";\nimport {\n  Address,\n  Indexer,\n  RPC,\n  config,\n  helpers,\n  Transaction,\n  HexString,\n  utils,\n  core,\n  toolkit,\n  Hash,\n  Cell,\n  HashType,\n  Script,\n  CellDep,\n} from \"@ckb-lumos/lumos\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport { ROLLUP_CONFIG } from \"./constants\";\nimport { PROVIDER_CONFIG } from \"./constants/providerConfig\";\nimport { PolyjuiceHttpProvider } from \"@polyjuice-provider/web3\";\nimport { SUDT_ERC20_PROXY_ABI } from \"./constants/sudtErc20ProxyAbi\";\nimport { AbiItems, PolyjuiceConfig } from \"@polyjuice-provider/base\";\nimport { GodwokenClient } from \"./godwoken/godwoken\";\nimport Web3 from \"web3\";\nimport { LightGodwokenProvider } from \"./lightGodwokenType\";\nimport { WithdrawalRequest } from \"./godwoken/normalizer\";\nimport { SerializeRcLockWitnessLock } from \"./omni-lock/index\";\nimport { TransactionWithStatus } from \"@ckb-lumos/base\";\n\nexport const POLYJUICE_CONFIG = {\n  web3Url: PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL,\n  abiItems: SUDT_ERC20_PROXY_ABI as AbiItems,\n};\n\nexport const polyjuiceProvider = new PolyjuiceHttpProvider(\n  POLYJUICE_CONFIG.web3Url,\n  POLYJUICE_CONFIG as PolyjuiceConfig,\n);\n\nexport default class DefaultLightGodwokenProvider implements LightGodwokenProvider {\n  l2Address: Address = \"\";\n  l1Address: Address = \"\";\n  ckbIndexer;\n  rpc;\n  ethereum;\n  web3;\n  godwokenClient;\n\n  constructor(ethAddress: Address, ethereum: any, env = \"AGGRON\") {\n    if (env === \"AGGRON\") {\n      config.initializeConfig(config.predefined.AGGRON4);\n      this.ckbIndexer = new Indexer(PROVIDER_CONFIG.AGGRON.CKB_INDEXER_URL, PROVIDER_CONFIG.AGGRON.CKB_RPC_URL);\n      this.rpc = new RPC(PROVIDER_CONFIG.AGGRON.CKB_RPC_URL);\n      this.godwokenClient = new GodwokenClient(PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL);\n    } else if (env === \"LINA\") {\n      config.initializeConfig(config.predefined.LINA);\n      this.ckbIndexer = new Indexer(PROVIDER_CONFIG.LINA.CKB_INDEXER_URL, PROVIDER_CONFIG.LINA.CKB_RPC_URL);\n      this.rpc = new RPC(PROVIDER_CONFIG.LINA.CKB_RPC_URL);\n      this.godwokenClient = new GodwokenClient(PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL);\n    } else {\n      throw new Error(\"env not defined, please use AGGRON or LINA.\");\n    }\n    this.ethereum = ethereum;\n    this.l2Address = ethAddress;\n    this.l1Address = this.generateL1Address(this.l2Address);\n    ethereum.on(\"accountsChanged\", (accounts: any) => {\n      console.log(\"eth accounts changed\", accounts);\n      this.l2Address = accounts[0];\n      this.l1Address = this.generateL1Address(this.l2Address);\n    });\n\n    this.web3 = new Web3(polyjuiceProvider);\n  }\n\n  async sendWithdrawTransaction(withdrawalRequest: WithdrawalRequest): Promise<string> {\n    const result = await this.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    return result as unknown as string;\n  }\n\n  getL2Address(): string {\n    return this.l2Address;\n  }\n  getL1Address(): string {\n    return this.l1Address;\n  }\n\n  static async CreateProvider(ethereum: any): Promise<LightGodwokenProvider> {\n    if (!ethereum || !ethereum.isMetaMask) {\n      throw new Error(\"please provide metamask ethereum object\");\n    }\n    return ethereum\n      .request({ method: \"eth_requestAccounts\" })\n      .then((accounts: any) => {\n        console.log(\"eth_requestAccounts\", accounts);\n        return new DefaultLightGodwokenProvider(accounts[0], ethereum);\n      })\n      .catch((error: any) => {\n        if (error.code === 4001) {\n          // EIP-1193 userRejectedRequest error\n          console.log(\"Please connect to MetaMask.\");\n        } else {\n          console.error(error);\n        }\n      });\n  }\n\n  generateL1Address(l2Address: Address): Address {\n    const omniLock: Script = {\n      code_hash: SCRIPTS.omni_lock.code_hash,\n      hash_type: SCRIPTS.omni_lock.hash_type as HashType,\n      // omni flag       pubkey hash   omni lock flags\n      // chain identity   eth addr      function flag()\n      // 00: Nervos                   00: owner\n      // 01: Ethereum                 01: administrator\n      //                            \n      args: `0x01${l2Address.substring(2)}00`,\n    };\n    return helpers.generateAddress(omniLock);\n  }\n\n  // // TODO the unknown is godwoken submit_withdrawal_tx\n  // sendWithdrawTransaction: (tx: unknown) => Promise<Hash>;\n\n  // // now only supported omni lock, the other lock type will be supported later\n  async sendL1Transaction(tx: Transaction): Promise<Hash> {\n    return await this.rpc.send_transaction(tx, \"passthrough\");\n  }\n\n  async signL1Transaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Transaction> {\n    const message = this.generateMessage(txSkeleton);\n    let signedMessage = await this.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.ethereum.selectedAddress, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    const signedWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs({\n        lock: SerializeRcLockWitnessLock({\n          signature: new toolkit.Reader(signedMessage),\n        }),\n      }),\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => witnesses.push(`${signedWitness}`));\n    const signedTx = helpers.createTransactionFromSkeleton(txSkeleton);\n    return signedTx;\n  }\n\n  generateMessage(tx: helpers.TransactionSkeletonType): HexString {\n    const hasher = new utils.CKBHasher();\n    const rawTxHash = utils.ckbHash(\n      core.SerializeRawTransaction(\n        toolkit.normalizers.NormalizeRawTransaction(helpers.createTransactionFromSkeleton(tx)),\n      ),\n    );\n    const serializedWitness = core.SerializeWitnessArgs({\n      lock: new toolkit.Reader(\n        \"0x\" +\n          \"00\".repeat(\n            SerializeRcLockWitnessLock({\n              signature: new toolkit.Reader(\"0x\" + \"00\".repeat(65)),\n            }).byteLength,\n          ),\n      ),\n    });\n    hasher.update(rawTxHash);\n    this.hashWitness(hasher, serializedWitness);\n    return hasher.digestHex();\n  }\n\n  hashWitness(hasher: utils.CKBHasher, witness: ArrayBuffer): void {\n    const lengthBuffer = new ArrayBuffer(8);\n    const view = new DataView(lengthBuffer);\n    view.setBigUint64(0, BigInt(new toolkit.Reader(witness).length()), true);\n    hasher.update(lengthBuffer);\n    hasher.update(witness);\n  }\n\n  async getPendingTransaction(txHash: Hash): Promise<TransactionWithStatus | null> {\n    let tx: TransactionWithStatus | null = null;\n\n    // retry 10 times, and sleep 1s\n    for (let i = 0; i < 10; i++) {\n      tx = await this.rpc.get_transaction(txHash);\n      if (tx != null) {\n        return tx;\n      }\n      await this.asyncSleep(1000);\n    }\n    return null;\n  }\n\n  async getRollupCellDep(): Promise<CellDep> {\n    const result = await this.godwokenClient.getLastSubmittedInfo();\n    const txHash = result.transaction_hash;\n    const tx = await this.getPendingTransaction(txHash);\n\n    if (tx == null) {\n      throw new Error(\"Last submitted tx not found!\");\n    }\n\n    let rollupIndex = tx.transaction.outputs.findIndex((o: any) => {\n      return o.type && utils.computeScriptHash(o.type) === ROLLUP_CONFIG.rollup_type_hash;\n    });\n    return {\n      out_point: {\n        tx_hash: txHash,\n        index: `0x${rollupIndex.toString(16)}`,\n      },\n      dep_type: \"code\",\n    };\n  }\n\n  async getRollupCell(): Promise<Cell | undefined> {\n    const queryOptions = {\n      type: {\n        code_hash: ROLLUP_CONFIG.rollup_type_script.code_hash as Hash,\n        hash_type: ROLLUP_CONFIG.rollup_type_script.hash_type as HashType,\n        args: ROLLUP_CONFIG.rollup_type_script.args as HexString,\n      },\n    };\n    const collector = this.ckbIndexer.collector(queryOptions);\n    let rollupCell;\n    for await (const cell of collector.collect()) {\n      if (cell === null) {\n        return undefined;\n      } else {\n        rollupCell = cell;\n        break;\n      }\n    }\n    return rollupCell;\n  }\n\n  async getLastFinalizedBlockNumber(): Promise<number> {\n    const rollupCell = await this.getRollupCell();\n    if (!rollupCell === undefined) {\n      return 0;\n    }\n    const globalState = new godwokenCore.GlobalState(new toolkit.Reader(rollupCell!.data));\n    const lastFinalizedBlockNumber = Number(globalState.getLastFinalizedBlockNumber().toLittleEndianBigUint64());\n    console.log(\"last finalized block number: \", lastFinalizedBlockNumber);\n    return lastFinalizedBlockNumber;\n  }\n\n  async asyncSleep(ms = 0) {\n    return new Promise((r) => setTimeout(r, ms));\n  }\n}\n","export const SUDT_ERC20_PROXY_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"string\",\n        name: \"name_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"string\",\n        name: \"symbol_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"totalSupply_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"sudtId_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint8\",\n        name: \"decimals_\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"sudtId\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"addedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"subtractedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n","import {\n  Cell,\n  CellDep,\n  core,\n  DepType,\n  Hash,\n  HashType,\n  helpers,\n  HexNumber,\n  HexString,\n  Script,\n  toolkit,\n  utils,\n  WitnessArgs,\n} from \"@ckb-lumos/lumos\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport EventEmitter from \"events\";\nimport * as secp256k1 from \"secp256k1\";\nimport { ROLLUP_CONFIG, SCRIPTS } from \"./constants\";\nimport { TOKEN_LIST } from \"./constants/tokens\";\nimport {\n  NormalizeDepositLockArgs,\n  NormalizeRawWithdrawalRequest,\n  NormalizeWithdrawalLockArgs,\n  RawWithdrawalRequest,\n  WithdrawalLockArgs,\n  WithdrawalRequest,\n} from \"./godwoken/normalizer\";\nimport LightGodwokenProvider, { POLYJUICE_CONFIG } from \"./lightGodwokenProvider\";\nimport {\n  DepositPayload,\n  GetErc20Balances,\n  GetErc20BalancesResult,\n  GetL1CkbBalancePayload,\n  GetL2CkbBalancePayload,\n  GetSudtBalances,\n  GetSudtBalancesResult,\n  L1MappedErc20,\n  L1Token,\n  LightGodwoken,\n  UnlockPayload,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  WithdrawResult,\n} from \"./lightGodwokenType\";\nimport {\n  SerializeDepositLockArgs,\n  SerializeRawWithdrawalRequest,\n  SerializeUnlockWithdrawalViaFinalize,\n  SerializeWithdrawalLockArgs,\n} from \"./schemas/index.esm\";\n\nexport default class DefaultLightGodwoken implements LightGodwoken {\n  provider: LightGodwokenProvider;\n  constructor(provider: LightGodwokenProvider) {\n    this.provider = provider;\n  }\n\n  async deposit(payload: DepositPayload): Promise<string> {\n    const neededCapacity = BigInt(payload.capacity);\n    const neededSudtAmount = payload.amount ? BigInt(payload.amount) : BigInt(0);\n    let collectedCapatity = BigInt(0);\n    let collectedSudtAmount = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: helpers.parseAddress(this.provider.l1Address) });\n    for await (const cell of collector.collect()) {\n      if (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\") {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      } else if (payload.sudtType && payload.sudtType.args === cell.cell_output.type?.args) {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedSudtAmount += BigInt(utils.readBigUInt128LE(cell.data));\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      }\n    }\n    if (collectedCapatity < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedCapatity} `);\n    }\n    if (collectedSudtAmount < neededSudtAmount) {\n      throw new Error(`Not enough SUDT, expected: ${neededSudtAmount}, actual: ${collectedSudtAmount} `);\n    }\n\n    const omniLockCellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.omni_lock.tx_hash,\n        index: SCRIPTS.omni_lock.index,\n      },\n      dep_type: SCRIPTS.omni_lock.dep_type as DepType,\n    };\n    const secp256k1CellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.secp256k1_blake160.tx_hash,\n        index: SCRIPTS.secp256k1_blake160.index,\n      },\n      dep_type: SCRIPTS.secp256k1_blake160.dep_type as DepType,\n    };\n    const outputCell = this.generateDepositOutputCell(collectedCells, payload);\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(...collectedCells);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCell);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(omniLockCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(secp256k1CellDep);\n      });\n\n    if (payload.sudtType) {\n      const sudtCellDep: CellDep = {\n        out_point: {\n          tx_hash: SCRIPTS.sudt.tx_hash,\n          index: SCRIPTS.sudt.index,\n        },\n        dep_type: SCRIPTS.sudt.dep_type as DepType,\n      };\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(sudtCellDep);\n      });\n    }\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n\n  generateDepositOutputCell(collectedCells: Cell[], payload: DepositPayload): Cell[] {\n    const ownerLock: Script = helpers.parseAddress(this.provider.l1Address);\n    const ownerLockHash: Hash = utils.computeScriptHash(ownerLock);\n    const layer2Lock: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + this.provider.l2Address.slice(2).toLowerCase(),\n    };\n    const depositLockArgs = {\n      owner_lock_hash: ownerLockHash,\n      layer2_lock: layer2Lock,\n      cancel_timeout: \"0xc0000000000004b0\",\n    };\n    const depositLockArgsHexString: HexString = new toolkit.Reader(\n      SerializeDepositLockArgs(NormalizeDepositLockArgs(depositLockArgs)),\n    ).serializeJson();\n    const depositLock: Script = {\n      code_hash: SCRIPTS.deposit_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + depositLockArgsHexString.slice(2),\n    };\n    const sumCapacity = collectedCells.reduce((acc, cell) => acc + BigInt(cell.cell_output.capacity), BigInt(0));\n    const sumSustAmount = collectedCells.reduce((acc, cell) => {\n      if (cell.cell_output.type) {\n        return acc + BigInt(utils.readBigUInt128LE(cell.data));\n      } else {\n        return acc;\n      }\n    }, BigInt(0));\n    const outputCell: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n        lock: depositLock,\n      },\n      data: \"0x\",\n    };\n    const exchangeCell: Cell = {\n      cell_output: {\n        // pay 0.0001 ckb for tx fee\n        capacity: \"0x\" + BigInt(sumCapacity - BigInt(payload.capacity) - BigInt(100000)).toString(16),\n        lock: helpers.parseAddress(this.provider.l1Address),\n      },\n      data: \"0x\",\n    };\n    if (payload.sudtType && payload.amount && payload.amount !== \"0x\" && payload.amount !== \"0x0\") {\n      outputCell.cell_output.type = payload.sudtType;\n      outputCell.data = utils.toBigUInt128LE(BigInt(payload.amount));\n      exchangeCell.cell_output.type = payload.sudtType;\n      exchangeCell.data = utils.toBigUInt128LE(sumSustAmount - BigInt(payload.amount));\n    }\n\n    return [outputCell, exchangeCell];\n  }\n\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime(): number {\n    return 45 * 1000;\n  }\n\n  async unlock(payload: UnlockPayload): Promise<Hash> {\n    const l1Address = this.provider.l1Address;\n    const l1Lock = helpers.parseAddress(l1Address);\n    const outputCells: Cell[] = [];\n    if (payload.cell.cell_output.type) {\n      const dummySudtCell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      };\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(dummySudtCell);\n      const capacityLeft = BigInt(payload.cell.cell_output.capacity) - sudtCapacity;\n\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${capacityLeft.toString(16)}`,\n          lock: l1Lock,\n        },\n        data: \"0x\",\n      });\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${sudtCapacity.toString(16)}`,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    } else {\n      outputCells.push({\n        cell_output: {\n          capacity: payload.cell.cell_output.capacity,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    }\n    const data =\n      \"0x00000000\" +\n      new toolkit.Reader(SerializeUnlockWithdrawalViaFinalize(toolkit.normalizers.NormalizeWitnessArgs({})))\n        .serializeJson()\n        .slice(2);\n    const newWitnessArgs: WitnessArgs = {\n      lock: data,\n    };\n    const withdrawalWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)),\n    ).serializeJson();\n\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n    const omniLockCellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.omni_lock.tx_hash,\n        index: SCRIPTS.omni_lock.index,\n      },\n      dep_type: SCRIPTS.omni_lock.dep_type as DepType,\n    };\n    const secp256k1CellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.secp256k1_blake160.tx_hash,\n        index: SCRIPTS.secp256k1_blake160.index,\n      },\n      dep_type: SCRIPTS.secp256k1_blake160.dep_type as DepType,\n    };\n    const withdrawalLockDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.withdrawal_lock.cell_dep.out_point.tx_hash,\n        index: SCRIPTS.withdrawal_lock.cell_dep.out_point.index,\n      },\n      dep_type: SCRIPTS.withdrawal_lock.cell_dep.dep_type as DepType,\n    };\n    const rollupCellDep: CellDep = await this.provider.getRollupCellDep();\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(payload.cell);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCells);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(withdrawalLockDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(rollupCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(omniLockCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(secp256k1CellDep);\n      })\n      .update(\"witnesses\", (witnesses) => {\n        return witnesses.push(withdrawalWitness);\n      });\n\n    if (payload.cell.cell_output.type) {\n      const sudtCellDep: CellDep = {\n        out_point: {\n          tx_hash: SCRIPTS.sudt.tx_hash,\n          index: SCRIPTS.sudt.index,\n        },\n        dep_type: SCRIPTS.sudt.dep_type as DepType,\n      };\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(sudtCellDep);\n      });\n    }\n\n    txSkeleton = await this.injectCapacity(txSkeleton, l1Lock, BigInt(0));\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerCKBLock = helpers.parseAddress(this.provider.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n\n    for await (const cell of collector.collect()) {\n      const rawLockArgs = cell.cell_output.lock.args;\n      const lockArgs = new godwokenCore.WithdrawalLockArgs(new toolkit.Reader(`0x${rawLockArgs.slice(66)}`));\n\n      if (lockArgs == null) {\n        continue;\n      }\n\n      const withdrawBlock = Number(lockArgs.getWithdrawalBlockNumber().toLittleEndianBigUint64());\n      const containsOwnerLock = cell.cell_output.lock.args.includes(ownerLockHash.substring(2));\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: L1MappedErc20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (containsOwnerLock) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock,\n          remainingBlockNumber: Math.max(0, withdrawBlock - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    const layer2Lock: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash as string,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + ethAddress.slice(2).toLowerCase(),\n    };\n    const accountScriptHash = utils.computeScriptHash(layer2Lock);\n\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: `${ROLLUP_CONFIG.rollup_type_hash}${accountScriptHash.slice(2)}`,\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const rollupTypeHash = ROLLUP_CONFIG.rollup_type_hash;\n    const ethAccountTypeHash = SCRIPTS.eth_account_lock.script_type_hash;\n    console.log(\" helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address)\", payload, this.provider);\n\n    const ownerLock = helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: ethAccountTypeHash,\n      hash_type: \"type\",\n      args: rollupTypeHash + ethAddress.slice(2),\n    };\n    const accountScriptHash = utils.computeScriptHash(l2AccountScript);\n    console.log(\"account script hash:\", accountScriptHash);\n    const fromId = await this.provider.godwokenClient.getAccountIdByScriptHash(accountScriptHash);\n    if (!fromId) {\n      throw new Error(\"account not found\");\n    }\n    const isSudt = payload.sudt_script_hash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    const minCapacity = this.minimalWithdrawalCapacity(isSudt);\n    if (BigInt(payload.capacity) < BigInt(minCapacity)) {\n      throw new Error(\n        `Withdrawal required ${BigInt(minCapacity)} shannons at least, provided ${BigInt(payload.capacity)}.`,\n      );\n    }\n    const nonce: HexNumber = await this.provider.godwokenClient.getNonce(fromId);\n    console.log(\"nonce:\", nonce);\n    const sellCapacity: HexNumber = \"0x0\";\n    const sellAmount: HexNumber = \"0x0\";\n    const paymentLockHash: HexNumber = \"0x\" + \"00\".repeat(32);\n    const feeSudtId: HexNumber = \"0x1\";\n    const feeAmount: HexNumber = \"0x0\";\n    const rawWithdrawalRequest: RawWithdrawalRequest = {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n      amount: \"0x\" + BigInt(payload.amount).toString(16),\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: accountScriptHash,\n      sell_amount: sellAmount,\n      sell_capacity: sellCapacity,\n      owner_lock_hash: ownerLockHash,\n      payment_lock_hash: paymentLockHash,\n      fee: {\n        sudt_id: feeSudtId,\n        amount: feeAmount,\n      },\n    };\n    console.log(\"rawWithdrawalRequest:\", rawWithdrawalRequest);\n    const message = this.generateWithdrawalMessageToSign(rawWithdrawalRequest, rollupTypeHash);\n    console.log(\"message:\", message);\n    const signatureMetamaskPersonalSign: HexString = await this.signMessageMetamaskPersonalSign(message);\n    console.log(\"signatureMetamaskPersonalSign:\", signatureMetamaskPersonalSign);\n    const withdrawalRequest: WithdrawalRequest = {\n      raw: rawWithdrawalRequest,\n      signature: signatureMetamaskPersonalSign,\n    };\n    console.log(\"withdrawalRequest:\", withdrawalRequest);\n    // using RPC `submitWithdrawalRequest` to submit withdrawal request to godwoken\n    let result: unknown;\n    try {\n      result = await this.provider.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    } catch (e) {\n      eventEmitter.emit(\"error\", e);\n      return;\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as unknown as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n\n  async getWithdrawal(txHash: Hash): Promise<unknown> {\n    const result = await this.provider.godwokenClient.getWithdrawal(txHash);\n    console.log(\"getWithdrawal result:\", result);\n    return result;\n  }\n\n  async signMessageMetamaskPersonalSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  async signMessageMetamaskEthSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  signMessage(message: Hash, privateKey: HexString): HexString {\n    const signObject = secp256k1.ecdsaSign(\n      new Uint8Array(new toolkit.Reader(message).toArrayBuffer()),\n      new Uint8Array(new toolkit.Reader(privateKey).toArrayBuffer()),\n    );\n    const signatureBuffer = new ArrayBuffer(65);\n    const signatureArray = new Uint8Array(signatureBuffer);\n    signatureArray.set(signObject.signature, 0);\n    let v = signObject.recid;\n    if (v >= 27) {\n      v -= 27;\n    }\n    signatureArray.set([v], 64);\n\n    const signature = new toolkit.Reader(signatureBuffer).serializeJson();\n    return signature;\n  }\n\n  generateWithdrawalMessageToSign(rawWithdrawalRequest: RawWithdrawalRequest, rollupTypeHash: Hash): Hash {\n    const serializedRawWithdrawalRequest: HexString = new toolkit.Reader(\n      SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(rawWithdrawalRequest)),\n    ).serializeJson();\n    const data = new toolkit.Reader(rollupTypeHash + serializedRawWithdrawalRequest.slice(2)).toArrayBuffer();\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  minimalWithdrawalCapacity(isSudt: boolean): HexNumber {\n    // fixed size, the specific value is not important.\n    const dummyHash: Hash = \"0x\" + \"00\".repeat(32);\n    const dummyHexNumber: HexNumber = \"0x0\";\n    const dummyRollupTypeHash: Hash = dummyHash;\n    const dummyWithdrawalLockArgs: WithdrawalLockArgs = {\n      account_script_hash: dummyHash,\n      withdrawal_block_hash: dummyHash,\n      withdrawal_block_number: dummyHexNumber,\n      sudt_script_hash: dummyHash,\n      sell_amount: dummyHexNumber,\n      sell_capacity: dummyHexNumber,\n      owner_lock_hash: dummyHash,\n      payment_lock_hash: dummyHash,\n    };\n    const serialized: HexString = new toolkit.Reader(\n      SerializeWithdrawalLockArgs(NormalizeWithdrawalLockArgs(dummyWithdrawalLockArgs)),\n    ).serializeJson();\n    const args = dummyRollupTypeHash + serialized.slice(2);\n    const lock: Script = {\n      code_hash: dummyHash,\n      hash_type: \"data\",\n      args,\n    };\n    let type: Script | undefined = undefined;\n    let data = \"0x\";\n    if (isSudt) {\n      type = {\n        code_hash: dummyHash,\n        hash_type: \"data\",\n        args: dummyHash,\n      };\n      data = \"0x\" + \"00\".repeat(16);\n    }\n    const cell: Cell = {\n      cell_output: {\n        lock,\n        type,\n        capacity: dummyHexNumber,\n      },\n      data,\n    };\n    const capacity: bigint = helpers.minimalCellCapacity(cell);\n    return \"0x\" + capacity.toString(16);\n  }\n\n  async getL2CkbBalance(payload?: GetL2CkbBalancePayload): Promise<HexNumber> {\n    const balance = await this.provider.web3.eth.getBalance(payload?.l2Address || this.provider.l2Address);\n    return \"0x\" + Number(balance).toString(16);\n  }\n\n  async getL1CkbBalance(payload?: GetL1CkbBalancePayload): Promise<HexNumber> {\n    const collector = this.provider.ckbIndexer.collector({ lock: helpers.parseAddress(this.provider.l1Address) });\n    let collectedSum = BigInt(0);\n    for await (const cell of collector.collect()) {\n      collectedSum += BigInt(cell.cell_output.capacity);\n    }\n    return \"0x\" + collectedSum.toString(16);\n  }\n\n  getBuiltinErc20List(): L1MappedErc20[] {\n    const map: L1MappedErc20[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      const tokenScriptHash = utils.computeScriptHash(tokenL1Script);\n      map.push({\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        address: token.address,\n        tokenURI: token.tokenURI,\n        sudt_script_hash: tokenScriptHash,\n      });\n    });\n    return map;\n  }\n\n  getBuiltinL1TokenList(): L1Token[] {\n    const map: L1Token[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      map.push({\n        type: tokenL1Script,\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        tokenURI: token.tokenURI,\n      });\n    });\n    return map;\n  }\n\n  async getErc20Balances(payload: GetErc20Balances): Promise<GetErc20BalancesResult> {\n    const result: GetErc20BalancesResult = { balances: [] };\n    let promises = [];\n    for (let index = 0; index < payload.addresses.length; index++) {\n      const address = payload.addresses[index];\n      const usdcContract = new this.provider.web3.eth.Contract(POLYJUICE_CONFIG.abiItems, address);\n      const usdcBalancePromise = usdcContract.methods.balanceOf(this.provider.l2Address).call();\n      promises.push(usdcBalancePromise);\n    }\n    await Promise.all(promises).then((values) => {\n      values.forEach((value) => {\n        result.balances.push(\"0x\" + Number(value).toString(16));\n      });\n    });\n    return result;\n  }\n\n  async getSudtBalances(payload: GetSudtBalances): Promise<GetSudtBalancesResult> {\n    const result: GetSudtBalancesResult = { balances: [] };\n    for (let index = 0; index < payload.types.length; index++) {\n      const type = payload.types[index];\n      const collector = this.provider.ckbIndexer.collector({\n        lock: helpers.parseAddress(this.provider.l1Address),\n        type,\n      });\n      let collectedSum = BigInt(0);\n      for await (const cell of collector.collect()) {\n        collectedSum += BigInt(utils.readBigUInt128LE(cell.data));\n      }\n      result.balances.push(\"0x\" + collectedSum.toString(16));\n    }\n    return result;\n  }\n\n  async injectCapacity(\n    tx: helpers.TransactionSkeletonType,\n    fromScript: Script,\n    capacity: bigint,\n  ): Promise<helpers.TransactionSkeletonType> {\n    // additional 0.001 ckb for tx fee\n    // the tx fee could calculated by tx size\n    // this is just a simple example\n    const neededCapacity = capacity + BigInt(100000);\n    let collectedSum = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: fromScript, type: \"empty\" });\n    for await (const cell of collector.collect()) {\n      if (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\" || cell.data === \"0x00\") {\n        collectedSum += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedSum >= neededCapacity) break;\n      }\n    }\n    if (collectedSum < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);\n    }\n    const changeOutput: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(collectedSum - neededCapacity).toString(16),\n        lock: fromScript,\n      },\n      data: \"0x\",\n    };\n    tx = tx.update(\"inputs\", (inputs) => inputs.push(...collectedCells));\n    tx = tx.update(\"outputs\", (outputs) => outputs.push(changeOutput));\n    return tx;\n  }\n}\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport React, { createContext, useEffect, useState } from \"react\";\nimport { LightGodwoken } from \"../light-godwoken\";\nimport DefaultLightGodwoken from \"../light-godwoken/lightGodwoken\";\nimport DefaultLightGodwokenProvider from \"../light-godwoken/lightGodwokenProvider\";\n\nexport const LightGodwokenContext = createContext<LightGodwoken | null>(null);\n\nexport const Provider: React.FC = (props) => {\n  const [lightGodwoken, setLightGodwoken] = useState<LightGodwoken>();\n\n  useEffect(() => {\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_accounts\" }).then((accounts: string[]) => {\n        if (!accounts || !accounts[0]) return;\n\n        const instance = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(accounts[0], ethereum));\n        setLightGodwoken(instance);\n      });\n\n      ethereum.on(\"accountsChanged\", (accounts: string[] | undefined) => {\n        if (!accounts || !accounts[0]) return setLightGodwoken(undefined);\n\n        const provider = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(ethereum.selectedAddress, ethereum));\n        setLightGodwoken(provider);\n      });\n    });\n  }, []);\n\n  return <LightGodwokenContext.Provider value={lightGodwoken || null}>{props.children}</LightGodwokenContext.Provider>;\n};\n","import { useContext } from \"react\";\nimport { LightGodwokenContext } from \"../contexts/LightGodwokenContext\";\nimport { LightGodwoken } from \"../light-godwoken\";\n\nexport const useLightGodwoken = (): LightGodwoken | null => {\n  const lightGodwoken = useContext(LightGodwokenContext);\n\n  return lightGodwoken;\n};\n","export const getDisplayAmount = (balance: BigInt, decimals = 8) => {\n  const valueStr = balance.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const unit = intPart === \"0\" ? 1e8 : 1e4;\n  let decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .slice(0, intPart === \"0\" ? 9 : 5);\n  decPart = (Math.round(Number(`0.${decPart}`) * unit) / unit)\n    .toFixed(intPart === \"0\" ? 8 : 4)\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(2);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n\nexport const getFullDisplayAmount = (value: BigInt, decimals = 8, options: { maxDecimalPlace?: number } = {}) => {\n  const { maxDecimalPlace = 4 } = options;\n\n  const valueStr = value.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(0, maxDecimalPlace);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst StyledInput = styled.input<{ error?: boolean; fontSize?: string; align?: string }>`\n  width: 0;\n  position: relative;\n  font-weight: 500;\n  outline: none;\n  border: none;\n  flex: 1 1 auto;\n  background-color: transparent;\n  font-size: 16px;\n  text-align: ${({ align }) => align && align};\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding: 0px;\n  -webkit-appearance: textfield;\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  [type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n\n  ::-webkit-outer-spin-button,\n  ::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n  }\n\n  :disabled {\n    cursor: text;\n  }\n`;\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\nconst inputRegex = RegExp(`^\\\\d*(?:\\\\\\\\[.])?\\\\d*$`); // match escaped \".\" characters via in a non-capturing group\n\nexport const Input = React.memo(function InnerInput({\n  value,\n  onUserInput,\n  placeholder,\n  ...rest\n}: {\n  value: string | number;\n  onUserInput: (input: string) => void;\n  error?: boolean;\n  fontSize?: string;\n  align?: \"right\" | \"left\";\n} & Omit<React.HTMLProps<HTMLInputElement>, \"ref\" | \"onChange\" | \"as\">) {\n  const enforcer = (nextUserInput: string) => {\n    if (nextUserInput === \"\" || inputRegex.test(escapeRegExp(nextUserInput))) {\n      onUserInput(nextUserInput);\n    }\n  };\n\n  return (\n    <StyledInput\n      {...rest}\n      value={value}\n      onChange={(event) => {\n        // replace commas with periods, because we exclusively uses period as the decimal separator\n        enforcer(event.target.value.replace(/,/g, \".\"));\n      }}\n      // universal input options\n      inputMode=\"decimal\"\n      title=\"Token Amount\"\n      autoComplete=\"off\"\n      autoCorrect=\"off\"\n      // text-specific options\n      type=\"text\"\n      pattern=\"^[0-9]*[.,]?[0-9]*$\"\n      placeholder={placeholder || \"0.0\"}\n      minLength={1}\n      maxLength={79}\n      spellCheck=\"false\"\n    />\n  );\n});\n\nexport default Input;\n","import { Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\nimport NumericalInput from \"./NumericalInput\";\n\nconst StyleWrapper = styled.div`\n  font-size: 14px;\n  border-radius: 16px;\n  background-color: rgb(60, 58, 75);\n  box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n  .first-row {\n    margin-bottom: 3px;\n    padding: 0.75rem 1rem 0px;\n  }\n  .anticon {\n    font-size: 12px;\n  }\n\n  .input-wrapper {\n    padding: 0.75rem 0.5rem 0.75rem 1rem;\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height: 24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n    height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\n\ninterface CKBInputPanelProps {\n  value: string;\n  onUserInput: (value: string) => void;\n  label?: string;\n}\nexport default function CKBInputPanel({ value, onUserInput, label }: CKBInputPanelProps) {\n  const [showMaxButton, setShowMaxButton] = useState(true);\n  const [l2CkbBalance, setL2CkbBalance] = useState(\"\");\n  const lightGodwoken = useLightGodwoken();\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const balance = (await lightGodwoken?.getL2CkbBalance()) || \"\";\n      setL2CkbBalance(balance);\n    };\n    fetchData();\n  }, [lightGodwoken]);\n\n  useEffect(() => {\n    if (value !== getDisplayAmount(BigInt(l2CkbBalance), 8)) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, l2CkbBalance]);\n\n  const handelMaxClick = () => {\n    onUserInput(getDisplayAmount(BigInt(l2CkbBalance), 8));\n    setShowMaxButton(false);\n  };\n  return (\n    <StyleWrapper>\n      <Row className=\"first-row\">\n        <Typography.Text>{label}</Typography.Text>\n        <Typography.Text>Balance: {getDisplayAmount(BigInt(l2CkbBalance), 8) || \"\"}</Typography.Text>\n      </Row>\n      <Row className=\"input-wrapper\">\n        <NumericalInput\n          className=\"token-amount-input\"\n          value={value}\n          placeholder=\"Minimum 400 CKB\"\n          onUserInput={(val) => {\n            onUserInput(val);\n          }}\n        />\n        {showMaxButton && (\n          <Typography.Text className=\"max-button\" onClick={handelMaxClick}>\n            MAX\n          </Typography.Text>\n        )}\n        <img className=\"ckb-logo\" src=\"./static/ckb.svg\" alt=\"\" />\n        <Typography.Text>CKB</Typography.Text>\n      </Row>\n    </StyleWrapper>\n  );\n}\n","const MINUTE_IN_SECONDS = 60;\nconst HOUR_IN_SECONDS = 3600;\nconst DAY_IN_SECONDS = 86400;\nconst MONTH_IN_SECONDS = 2629800;\nconst YEAR_IN_SECONDS = 31557600;\n\n/**\n * Format number of seconds into year, month, day, hour, minute, seconds\n *\n * @param seconds\n */\nconst getTimePeriods = (seconds: number) => {\n  let delta = Math.abs(seconds);\n  const timeLeft = {\n    years: 0,\n    months: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n  };\n\n  if (delta >= YEAR_IN_SECONDS) {\n    timeLeft.years = Math.floor(delta / YEAR_IN_SECONDS);\n    delta -= timeLeft.years * YEAR_IN_SECONDS;\n  }\n\n  if (delta >= MONTH_IN_SECONDS) {\n    timeLeft.months = Math.floor(delta / MONTH_IN_SECONDS);\n    delta -= timeLeft.months * MONTH_IN_SECONDS;\n  }\n\n  if (delta >= DAY_IN_SECONDS) {\n    timeLeft.days = Math.floor(delta / DAY_IN_SECONDS);\n    delta -= timeLeft.days * DAY_IN_SECONDS;\n  }\n\n  if (delta >= HOUR_IN_SECONDS) {\n    timeLeft.hours = Math.floor(delta / HOUR_IN_SECONDS);\n    delta -= timeLeft.hours * HOUR_IN_SECONDS;\n  }\n\n  if (delta >= MINUTE_IN_SECONDS) {\n    timeLeft.minutes = Math.floor(delta / MINUTE_IN_SECONDS);\n    delta -= timeLeft.minutes * MINUTE_IN_SECONDS;\n  }\n\n  timeLeft.seconds = Math.floor(delta);\n\n  return timeLeft;\n};\n\nexport default getTimePeriods;\n","/* eslint-disable */\nimport React, { useState, useCallback, useEffect, useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { DownOutlined, UpOutlined } from \"@ant-design/icons\";\nimport { Button, Popconfirm, Typography, notification, Modal } from \"antd\";\nimport getTimePeriods from \"../utils/getTimePeriods\";\nimport { getDisplayAmount, getFullDisplayAmount } from \"../utils/formatTokenAmount\";\nimport { Cell, HexNumber } from \"@ckb-lumos/lumos\";\nimport { L1MappedErc20 } from \"../light-godwoken/lightGodwokenType\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { Link } from \"react-router-dom\";\nconst { Text } = Typography;\nconst StyleWrapper = styled.div`\n  background: rgb(39, 37, 52);\n  padding: 16px;\n  border-radius: 12px;\n  .header {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    font-weight: 400;\n    line-height: 1.5;\n    font-size: 14px;\n  }\n  .icons {\n    display: flex;\n    img {\n      width: 20px;\n      height: 20px;\n      margin-right: 5px;\n    }\n  }\n  .ckb-icon {\n    width: 20px;\n    height: 20px;\n    background: url(./static/ckb.svg) no-repeat no-repeat;\n    background-size: contain;\n  }\n  .number {\n    margin-top: 3px;\n  }\n  .time {\n    align-self: center;\n    display: flex;\n    height: 40px;\n    align-items: center;\n    .ant-typography {\n      padding-right: 5px;\n    }\n  }\n  .ant-typography {\n    color: white;\n  }\n  .list-detail {\n    padding-top: 10px;\n  }\n`;\nconst PrimaryButton = styled(Button)`\n  align-items: center;\n  border: 0px;\n  border-radius: 16px;\n  box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n  cursor: pointer;\n  display: inline-flex;\n  font-family: inherit;\n  font-size: 16px;\n  font-weight: 600;\n  -webkit-box-pack: center;\n  justify-content: center;\n  letter-spacing: 0.03em;\n  line-height: 1;\n  opacity: 1;\n  outline: 0px;\n  transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n  height: 32px;\n  padding: 0px 16px;\n  background-color: rgb(255, 67, 66);\n  color: white;\n  margin-left: 4px;\n  margin-top: 8px;\n  &:hover,\n  &:focus,\n  &:active {\n    background-color: rgb(255, 67, 66);\n    color: white;\n  }\n`;\nconst PlainButton = styled.div`\n  align-items: center;\n  border: 0px;\n  border-radius: 16px;\n  box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n  cursor: pointer;\n  display: inline-flex;\n  font-family: inherit;\n  font-size: 16px;\n  font-weight: 600;\n  -webkit-box-pack: center;\n  justify-content: center;\n  letter-spacing: 0.03em;\n  line-height: 1;\n  opacity: 1;\n  outline: 0px;\n  transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n  height: 32px;\n  padding: 0px 16px;\n  background-color: rgb(60, 58, 75);\n  color: white;\n  margin-left: 4px;\n  margin-top: 8px;\n  &:hover,\n  &:focus,\n  &:active {\n    background-color: rgb(60, 58, 75);\n    color: white;\n  }\n`;\n\nexport const FixedHeightRow = styled.div`\n  height: 24px;\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n`;\nconst UnlockModal = styled(Modal)`\n  color: white;\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n  .ant-modal-title {\n    color: white;\n  }\n  .ant-modal-body {\n    padding: 20px;\n  }\n  .ant-modal-close-x {\n    color: white;\n  }\n  .ant-typography {\n    color: white;\n    display: block;\n  }\n  .ant-typography.title {\n    font-size: 20px;\n    padding-bottom: 10px;\n  }\n  .actions {\n    padding-top: 20px;\n    display: flex;\n    justify-content: center;\n  }\n  .confirm {\n    margin-left: 30px;\n  }\n  .confirm,\n  .cancel {\n    border-radius: 6px;\n  }\n`;\n\nexport interface IWithdrawalRequestCardProps {\n  remainingBlockNumber: number;\n  capacity: HexNumber;\n  amount: HexNumber;\n  cell: Cell;\n  erc20?: L1MappedErc20;\n  now?: number;\n}\n\nconst WithdrawalRequestCard = ({\n  remainingBlockNumber,\n  capacity,\n  amount,\n  erc20,\n  now = 0,\n  cell,\n}: IWithdrawalRequestCardProps) => {\n  const [shouldShowMore, setShouldShowMore] = useState(false);\n  const [blockProduceTime, setBlockProduceTime] = useState(0);\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  const [isUnlocking, setIsUnlocking] = useState(false);\n  const lightGodwoken = useLightGodwoken();\n\n  const handleToggleShowMore = useCallback(() => {\n    setShouldShowMore((value) => !value);\n  }, []);\n  useEffect(() => {\n    const fetchBlockProduceTime = async () => {\n      const result: number = (await lightGodwoken?.getBlockProduceTime()) || 0;\n      setBlockProduceTime(result);\n    };\n    fetchBlockProduceTime();\n  }, [lightGodwoken]);\n\n  const estimatedArrivalDate = useMemo(\n    () => Date.now() + remainingBlockNumber * blockProduceTime,\n    [blockProduceTime, remainingBlockNumber],\n  );\n  const estimatedSecondsLeft = useMemo(() => Math.max(0, estimatedArrivalDate - now), [now, estimatedArrivalDate]);\n  const isMature = useMemo(() => remainingBlockNumber === 0, [remainingBlockNumber]);\n\n  const {\n    days: daysLeft,\n    hours: hoursLeft,\n    minutes: minutesLeft,\n    seconds: secondsLeft,\n  } = useMemo(() => getTimePeriods(estimatedSecondsLeft / 1000), [estimatedSecondsLeft]);\n  const [ckbAmount, ckbFullAmount] = useMemo(() => {\n    if (capacity === \"0\") {\n      console.error(\"[warn] a withdrawal request cell with zero capacity\");\n      return [\"\", \"\"];\n    }\n    const capacityBI = BigInt(capacity);\n    return [`${getDisplayAmount(capacityBI, 8)} CKB`, `${getFullDisplayAmount(capacityBI, 8)} CKB`];\n  }, [capacity]);\n\n  const [sudtAmount, sudtFullAmount] = useMemo(() => {\n    if (amount === \"\" || !erc20) {\n      return [\"\", \"\"];\n    }\n    const amountBI = BigInt(amount);\n\n    return [\n      `${getDisplayAmount(amountBI, erc20.decimals)} ${erc20.symbol}`,\n      `${getFullDisplayAmount(amountBI, erc20.decimals)} ${erc20.symbol}`,\n    ];\n  }, [amount, erc20]);\n\n  const unlock = async () => {\n    setIsUnlocking(true);\n    const txHash = await lightGodwoken?.unlock({ cell });\n    setIsUnlocking(false);\n    const linkToExplorer = () => {\n      window.open(`https://explorer.nervos.org/aggron/transaction/${txHash}`, \"_blank\");\n    };\n    setIsModalVisible(false);\n    notification.success({ message: `Unlock Tx(${txHash}) is successful`, onClick: linkToExplorer });\n  };\n\n  const showCurrencySelectModal = () => {\n    setIsModalVisible(true);\n  };\n\n  const handleOk = () => {\n    setIsModalVisible(false);\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n\n  return (\n    <StyleWrapper onClick={isMature ? undefined : handleToggleShowMore}>\n      <div className=\"header\">\n        <div className=\"amount\">\n          <div className=\"icons\">\n            {erc20?.tokenURI ? <img src={erc20?.tokenURI} alt=\"\" /> : \"\"}\n            <div className=\"ckb-icon\"></div>\n          </div>\n          <div className=\"number\">\n            {sudtAmount}\n            {sudtAmount === \"\" ? \"\" : \" and \"}\n            {ckbAmount}\n          </div>\n        </div>\n        {isMature ? (\n          <PrimaryButton className=\"withdraw-button\" onClick={showCurrencySelectModal}>\n            withdraw\n          </PrimaryButton>\n        ) : shouldShowMore ? (\n          <div className=\"time\">\n            <UpOutlined />\n          </div>\n        ) : (\n          <div className=\"time\">\n            <Text title=\"Estimated time left\">\n              {daysLeft > 0\n                ? `${daysLeft}${daysLeft > 1 ? \" days\" : \" day\"}`\n                : `${hoursLeft > 0 ? `${hoursLeft.toString().padStart(2, \"0\")}:` : \"\"}${minutesLeft\n                    .toString()\n                    .padStart(2, \"0\")}:${secondsLeft.toString().padStart(2, \"0\")}`}\n            </Text>\n            <DownOutlined />\n          </div>\n        )}\n      </div>\n      {shouldShowMore && (\n        <div className=\"list-detail\">\n          <FixedHeightRow>\n            <Text>Blocks remaining:</Text>\n            <Text>{remainingBlockNumber}</Text>\n          </FixedHeightRow>\n          <FixedHeightRow>\n            <Text>Estimated time left:</Text>\n            <Text>\n              {`${daysLeft > 0 ? `${daysLeft}${daysLeft > 1 ? \" days \" : \" day \"}` : \"\"}${hoursLeft\n                .toString()\n                .padStart(2, \"0\")}:${minutesLeft.toString().padStart(2, \"0\")}:${secondsLeft\n                .toString()\n                .padStart(2, \"0\")}`}\n            </Text>\n          </FixedHeightRow>\n        </div>\n      )}\n      <UnlockModal\n        title=\"Withdraw to Wallet\"\n        visible={isModalVisible}\n        onOk={handleOk}\n        onCancel={handleCancel}\n        footer={null}\n      >\n        <Text className=\"title\">Confirm Unlock Withdrawal to below address</Text>\n        <Text>{lightGodwoken?.provider.getL1Address()}</Text>\n        <div className=\"actions\">\n          <PlainButton className=\"cancel\" onClick={handleCancel}>\n            Cancel\n          </PlainButton>\n          <PrimaryButton className=\"confirm\" onClick={unlock} loading={isUnlocking}>\n            Confirm\n          </PrimaryButton>\n        </div>\n      </UnlockModal>\n    </StyleWrapper>\n  );\n};\n\nexport default WithdrawalRequestCard;\n","import styled from \"styled-components\";\nimport { Typography, Modal, List } from \"antd\";\nimport { FixedHeightRow } from \"./WithdrawalRequestCard\";\nimport NumericalInput from \"./NumericalInput\";\nimport { DownOutlined } from \"@ant-design/icons\";\nimport React, { useState, useEffect } from \"react\";\nimport { L1MappedErc20 } from \"../types/type\";\nimport { getFullDisplayAmount } from \"../utils/formatTokenAmount\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nconst { Text } = Typography;\nconst StyleWrapper = styled.div`\n  border-radius: 16px;\n  background-color: rgb(60, 58, 75);\n  box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n  .first-row {\n    margin-bottom: 3px;\n  }\n  .anticon {\n    font-size: 12px;\n  }\n  .max-button {\n    height: 32px;\n    line-height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n  }\n  .token-list {\n    height: 390px;\n    overflow-y: auto;\n  }\n  .first-row {\n    margin-bottom: 3px;\n    padding: 0.75rem 1rem 0px;\n  }\n  .input-wrapper {\n    height: 56px;\n    padding: 0.75rem 0.5rem 0.75rem 1rem;\n    display: flex;\n    align-items: center;\n  }\n  .currency-wrapper {\n    display: flex;\n    align-items: center;\n  }\n  .anticon {\n    margin-left: 10px;\n  }\n`;\n\nconst TokenList = styled.div`\n  height: 390px;\n  overflow-y: auto;\n`;\n\nconst TokenListModal = styled(Modal)`\n  color: white;\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n  .ant-modal-title,\n  .ant-list-item {\n    color: white;\n  }\n  .ant-modal-body {\n    padding: 0px;\n  }\n  .ant-modal-close-x {\n    color: white;\n  }\n  .ant-list-item {\n    border-bottom: none;\n    padding: 4px 20px;\n    height: 56px;\n    &:hover {\n      background-color: rgb(60, 58, 75);\n      cursor: pointer;\n    }\n    &.selected {\n      background-color: rgb(60, 58, 75);\n    }\n  }\n  .currency-item {\n    width: 100%;\n    .info {\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n    }\n    .icon {\n      width: 24px;\n      height: 24px;\n      margin-right: 10px;\n    }\n    .symbol-name {\n      display: flex;\n      flex-direction: column;\n      .symbol {\n        font-size: 16px;\n        font-weight: 600;\n        line-height: 1.5;\n      }\n      .name {\n        font-size: 14px;\n        line-height: 1.5;\n      }\n    }\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height: 24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n    height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n  }\n`;\n\ninterface CurrencyInputPanelProps {\n  value: string;\n  onUserInput: (value: string) => void;\n  label?: string;\n  disableCurrencySelect?: boolean;\n  hideBalance?: boolean;\n  hideInput?: boolean;\n  showCommonBases?: boolean;\n  disableInput?: boolean;\n  autoFocus?: boolean;\n  transparent?: boolean;\n  onSelectedChange: (value: L1MappedErc20) => void;\n}\nexport default function CurrencyInputPanel({\n  autoFocus,\n  disableInput,\n  value,\n  onUserInput,\n  label,\n  onSelectedChange,\n}: CurrencyInputPanelProps) {\n  const [selectedCurrencyBalance, setCurrencyBalance] = useState(\"\");\n  const [showMaxButton, setShowMaxButton] = useState(false);\n  const [erc20List, setErc20List] = useState<L1MappedErc20[]>([]);\n  const [balancesList, setBalancesList] = useState<string[]>([]);\n  const [selectedCurrency, setSelectedCurrency] = useState<L1MappedErc20>();\n  const [selectedIndex, setSelectedIndex] = useState<number>();\n  const lightGodwoken = useLightGodwoken();\n  const showCurrencySelectModal = () => {\n    setIsModalVisible(true);\n  };\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  useEffect(() => {\n    const fetchData = async () => {\n      if (lightGodwoken) {\n        const results: L1MappedErc20[] = lightGodwoken.getBuiltinErc20List();\n        setErc20List(results);\n        const addressList = results.map((erc20) => erc20.address);\n        const balances = await lightGodwoken.getErc20Balances({ addresses: addressList });\n        setBalancesList(balances.balances);\n      }\n    };\n    fetchData();\n  }, [lightGodwoken]);\n\n  useEffect(() => {\n    if (selectedCurrency && (value !== selectedCurrencyBalance || value === \"\")) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, selectedCurrencyBalance, selectedCurrency]);\n\n  useEffect(() => {\n    if (balancesList && balancesList.length && selectedIndex !== undefined && selectedCurrency) {\n      const balance = balancesList[selectedIndex];\n      const currencyBalance = getFullDisplayAmount(BigInt(balance), selectedCurrency.decimals);\n      setCurrencyBalance(currencyBalance);\n    }\n  }, [selectedIndex, balancesList, selectedCurrency]);\n\n  const handleOk = () => {\n    setIsModalVisible(false);\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n  const handleErc20Selected = (index: number, erc20: L1MappedErc20) => {\n    setSelectedCurrency(erc20);\n    onSelectedChange(erc20);\n    setIsModalVisible(false);\n    setShowMaxButton(true);\n    onUserInput(\"\");\n    setSelectedIndex(index);\n  };\n  const handelMaxClick = () => {\n    onUserInput(selectedCurrencyBalance);\n    setShowMaxButton(false);\n  };\n  return (\n    <StyleWrapper>\n      <Row className=\"first-row\">\n        <Typography.Text>{label}</Typography.Text>\n        <Typography.Text>{selectedCurrencyBalance || \"\"}</Typography.Text>\n      </Row>\n      <Row className=\"input-wrapper\">\n        <NumericalInput\n          autoFocus={autoFocus}\n          disabled={disableInput}\n          className=\"token-amount-input\"\n          value={value}\n          onUserInput={(val) => {\n            onUserInput(val);\n          }}\n        />\n        {showMaxButton && (\n          <div className=\"max-button\" onClick={handelMaxClick}>\n            MAX\n          </div>\n        )}\n        <div className=\"currency-wrapper\" onClick={showCurrencySelectModal}>\n          {selectedCurrency ? (\n            <div className=\"currency-icon\">\n              <img className=\"ckb-logo\" src={selectedCurrency.tokenURI} alt=\"\" />\n              <Typography.Text>{selectedCurrency.symbol}</Typography.Text>\n            </div>\n          ) : (\n            <Text>Select a currency </Text>\n          )}\n          <DownOutlined />\n        </div>\n      </Row>\n      <TokenListModal\n        title=\"Select a Token\"\n        visible={isModalVisible}\n        onOk={handleOk}\n        onCancel={handleCancel}\n        footer={null}\n      >\n        <TokenList className=\"token-list\">\n          <List\n            dataSource={erc20List}\n            renderItem={(erc20, index) => (\n              <List.Item\n                className={erc20.address === selectedCurrency?.address ? \"selected\" : \"\"}\n                onClick={() => handleErc20Selected(index, erc20)}\n              >\n                <FixedHeightRow className=\"currency-item\">\n                  <div className=\"info\">\n                    <img className=\"icon\" src={erc20.tokenURI} alt=\"\" />\n                    <div className=\"symbol-name\">\n                      <Text className=\"symbol\">{erc20.symbol}</Text>\n                      <Text className=\"name\">{erc20.name}</Text>\n                    </div>\n                  </div>\n                  <div>\n                    {balancesList.length ? getFullDisplayAmount(BigInt(balancesList[index]), erc20.decimals) : \"\"}\n                  </div>\n                </FixedHeightRow>\n              </List.Item>\n            )}\n          ></List>\n        </TokenList>\n      </TokenListModal>\n    </StyleWrapper>\n  );\n}\n","import { CopyOutlined } from \"@ant-design/icons\";\nimport { Button, Input, Tooltip } from \"antd\";\nimport React, { useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\n\nconst TipWrapper = styled.div`\n  color: #fff;\n  .text-pair {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\n\nfunction truncateMiddle(str: string, first = 6, last = 4): string {\n  return str.substring(0, first) + \"...\" + str.substring(str.length - last);\n}\n\nexport const Address: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = useMemo(() => {\n    if (!lightGodwoken) return undefined;\n    return lightGodwoken.provider.getL2Address();\n  }, [lightGodwoken]);\n\n  if (!lightGodwoken || !l2Address) return null;\n\n  return (\n    <Tooltip\n      title={\n        <TipWrapper>\n          <div className=\"address-content\">\n            <label htmlFor=\"\">ETH ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL2Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n          {/* <div className=\"text-pair\">\n            <Text>L2 CKB Balance</Text>\n            <Text>{getFullDisplayAmount(BigInt(l2CkbBalance), 8)}</Text>\n          </div> */}\n          <div className=\"address-content\">\n            <label htmlFor=\"\">L1 WALLET ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL1Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n        </TipWrapper>\n      }\n    >\n      {truncateMiddle(l2Address)}\n    </Tooltip>\n  );\n};\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { Button } from \"antd\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\nimport { Address } from \"../Address\";\nconst StyleWrapper = styled(Button)`\n  &.ant-btn-primary {\n    background: rgb(60, 58, 75);\n    border: none;\n  }\n`;\nexport const ConnectButton: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  function connectWallet() {\n    if (lightGodwoken) return;\n\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_requestAccounts\" });\n    });\n  }\n\n  return (\n    <StyleWrapper type=\"primary\" onClick={connectWallet}>\n      {lightGodwoken ? <Address /> : \"Connect\"}\n    </StyleWrapper>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { ConnectButton } from \"../components/ConnectButton\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  padding: 16px;\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n  margin-bottom: 20px;\n  color: white;\n  .address:hover {\n    cursor: pointer;\n  }\n`;\n\nconst PageHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  return (\n    <StyledPage>\n      <div className=\"icon\"></div>\n      <div className=\"title\">Withdrawal</div>\n      <div className=\"address\">\n        <ConnectButton />\n      </div>\n    </StyledPage>\n  );\n};\n\nexport default PageHeader;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport PageHeader from \"./PageHeader\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-height: calc(100vh);\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n`;\n\nconst Page: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {\n  return (\n    <StyledPage {...props}>\n      <PageHeader></PageHeader>\n      {children}\n    </StyledPage>\n  );\n};\n\nexport default Page;\n","import { ArrowLeftOutlined, PlusOutlined, QuestionCircleOutlined } from \"@ant-design/icons\";\nimport { Button, Modal, notification, Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { WithdrawalEventEmitter } from \"../light-godwoken/lightGodwokenType\";\nimport { L1MappedErc20 } from \"../types/type\";\nimport CKBInputPanel from \"./CKBInputPanel\";\nimport CurrencyInputPanel from \"./CurrencyInputPanel\";\nimport Page from \"./Page\";\n\nconst { Text } = Typography;\n\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n`;\nconst PageHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  padding: 24px;\n  align-items: center;\n  a,\n  .ant-typography {\n    color: white;\n  }\n`;\nconst PageMain = styled.div`\n  padding: 24px;\n  grid-auto-rows: auto;\n  row-gap: 8px;\n  .icon {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n`;\nconst WithDrawalButton = styled.div`\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n  .submit-button {\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n    width: 100%;\n    &:disabled {\n      background-color: rgb(60, 55, 66);\n      border-color: rgb(60, 55, 66);\n      box-shadow: none;\n      color: rgb(104, 102, 123);\n      cursor: not-allowed;\n    }\n  }\n  button:hover {\n    cursor: pointer;\n  }\n`;\nconst ConfirmModal = styled(Modal)`\n  color: white;\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n  .ant-modal-title,\n  .ant-list-item {\n    color: white;\n  }\n  .ant-modal-body {\n    padding: 24px;\n  }\n  .ant-modal-close-x {\n    color: white;\n  }\n  .ant-typography {\n    color: white;\n    justify-content: space-between;\n  }\n  .text-pair {\n    padding-top: 5px;\n    display: flex;\n    justify-content: space-between;\n    font-size: 24px;\n  }\n  .tips {\n    margin: 24px 0;\n  }\n`;\nexport default function RequestWithdrawal() {\n  const [ckbInput, setCkbInput] = useState(\"\");\n  const [outputValue, setOutputValue] = useState(\"\");\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [submitButtonDisable, setSubmitButtonDisable] = useState(true);\n  const [selectedSudt, setSelectedSudt] = useState<L1MappedErc20>();\n  const lightGodwoken = useLightGodwoken();\n\n  const showModal = () => {\n    setIsModalVisible(true);\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n\n  useEffect(() => {\n    if (Number(ckbInput) >= 400) {\n      setSubmitButtonDisable(false);\n    } else {\n      setSubmitButtonDisable(true);\n    }\n  }, [ckbInput]);\n\n  const sendWithDrawal = () => {\n    setLoading(true);\n    const capacity = BigInt(ckbInput) * BigInt(Math.pow(10, 8));\n    let amount = \"0x0\";\n    let sudt_script_hash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    if (selectedSudt) {\n      amount = \"0x\" + BigInt(Number(outputValue) * Math.pow(10, selectedSudt.decimals)).toString(16);\n      sudt_script_hash = selectedSudt.sudt_script_hash;\n    }\n    if (!lightGodwoken) {\n      return;\n    }\n    let e: WithdrawalEventEmitter;\n    try {\n      e = lightGodwoken.withdrawWithEvent({\n        capacity: \"0x\" + capacity.toString(16),\n        amount: amount,\n        sudt_script_hash: sudt_script_hash,\n      });\n    } catch (e) {\n      console.log(\"withdrawal error:\", e);\n      return;\n    }\n\n    e.on(\"sent\", (txHash) => {\n      setIsModalVisible(false);\n      notification.info({ message: `Withdrawal Tx(${txHash}) has sent` });\n      setLoading(false);\n    });\n\n    e.on(\"pending\", (result) => {\n      console.log(\"pending triggerd\", result);\n    });\n\n    e.on(\"success\", (txHash) => {\n      setIsModalVisible(false);\n      notification.success({ message: `Withdrawal Tx(${txHash}) is successful` });\n    });\n\n    e.on(\"error\", (result: unknown) => {\n      setLoading(false);\n      notification.error({ message: result instanceof Error ? result.message : JSON.stringify(result) });\n    });\n  };\n\n  return (\n    <Page>\n      <PageContent>\n        <PageHeader className=\"header\">\n          <Link to=\"/\">\n            <ArrowLeftOutlined />\n          </Link>\n          <Text>Request Withdrawal</Text>\n          <QuestionCircleOutlined />\n        </PageHeader>\n        <PageMain className=\"main\">\n          <CKBInputPanel value={ckbInput} onUserInput={setCkbInput} label=\"Withdraw\"></CKBInputPanel>\n          <div className=\"icon\">\n            <PlusOutlined />\n          </div>\n          <CurrencyInputPanel\n            value={outputValue}\n            onUserInput={setOutputValue}\n            label=\"sUDT(optional)\"\n            onSelectedChange={setSelectedSudt}\n          ></CurrencyInputPanel>\n          <WithDrawalButton>\n            <Button className=\"submit-button\" disabled={submitButtonDisable} onClick={showModal}>\n              Request Withdrawal\n            </Button>\n          </WithDrawalButton>\n        </PageMain>\n        <div className=\"footer\">\n          {/* <ProgressStepper currentStep={0} steps={withdrawalSteps}></ProgressStepper> */}\n        </div>\n      </PageContent>\n      <ConfirmModal title=\"Confirm Request\" visible={isModalVisible} onCancel={handleCancel} footer={null}>\n        <div className=\"text-pair\">\n          <Text>Block wait</Text>\n          <Text>10000</Text>\n        </div>\n        <div className=\"text-pair\">\n          <Text>Estimated time</Text>\n          <Text>5 days</Text>\n        </div>\n        <div className=\"tips\">\n          Layer 2 assets will be locked in Withdrawal Request, available to withdraw to Layer 1 after maturity. Request\n          Withdrawal\n        </div>\n        <WithDrawalButton>\n          <Button className=\"submit-button\" loading={loading} onClick={sendWithDrawal}>\n            Request Withdrawal\n          </Button>\n        </WithDrawalButton>\n      </ConfirmModal>\n    </Page>\n  );\n}\n","import Page from \"./Page\";\nimport styled from \"styled-components\";\nimport WithdrawalRequestCard from \"./WithdrawalRequestCard\";\nimport { useEffect, useState } from \"react\";\nimport { WithdrawResult } from \"../types/type\";\nimport { Link } from \"react-router-dom\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { useClock } from \"../hooks/useClock\";\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n  .request-withdrawal {\n    padding: 24px;\n  }\n  .title {\n    font-size: 20px;\n    font-weight: 600;\n    line-height: 1.1;\n    margin-bottom: 8px;\n  }\n  .description {\n    font-weight: 400;\n    line-height: 1.5;\n    font-size: 14px;\n  }\n  .button-container {\n    margin-top: 16px;\n  }\n  .request-button {\n    -webkit-box-align: center;\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n  }\n`;\n\nconst ResultList = styled.div`\n  > .header {\n    -webkit-box-align: center;\n    align-items: center;\n    -webkit-box-pack: justify;\n    justify-content: space-between;\n    padding: 24px;\n    width: 100%;\n    border-bottom: 1px solid rgb(60, 58, 75);\n    border-top: 1px solid rgb(60, 58, 75);\n    font-size: 16px;\n    font-weight: 600;\n    line-height: 1.5;\n  }\n  .list {\n    max-height: calc(100vh - 400px);\n    overflow-y: auto;\n    background-color: rgb(16, 12, 24);\n    padding: 24px;\n    border-bottom-left-radius: 24px;\n    border-bottom-right-radius: 24px;\n    & > div {\n      margin-bottom: 16px;\n    }\n  }\n`;\n\nconst Withdrawal: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  const [withdrawList, setWithdrawList] = useState<WithdrawResult[]>([]);\n  const lightGodwoken = useLightGodwoken();\n  const now = useClock();\n  useEffect(() => {\n    const fetchWithdrawList = async () => {\n      if (lightGodwoken) {\n        const results: WithdrawResult[] = await lightGodwoken?.listWithdraw();\n        setWithdrawList(results);\n      }\n    };\n    fetchWithdrawList();\n  }, [lightGodwoken]);\n  return (\n    <Page>\n      <PageContent className=\"content\">\n        <div className=\"request-withdrawal\">\n          <div className=\"title\">Withdrawal</div>\n          <div className=\"description\">\n            To withdraw assets back to Layer 1, you need to have CKB balance in your L1 Wallet Address\n          </div>\n          <div className=\"button-container\">\n            <Link to=\"/request-withdrawal\" className=\"request-button\">\n              Request Withdrawal\n            </Link>\n          </div>\n        </div>\n        <ResultList className=\"withdrawal-request\">\n          <div className=\"header\">Your Withdrawal Requests</div>\n          <div className=\"list\">\n            {withdrawList.map((withdraw, index) => (\n              <WithdrawalRequestCard now={now} {...withdraw} key={index}></WithdrawalRequestCard>\n            ))}\n          </div>\n        </ResultList>\n      </PageContent>\n    </Page>\n  );\n};\n\nexport default Withdrawal;\n","import { useEffect, useState } from \"react\";\n\nexport function useClock(): number {\n  const [now, setTime] = useState(() => Date.now());\n\n  useEffect(() => {\n    const loop = () => {\n      setTime(Date.now());\n      setTimeout(loop, 1000);\n    };\n\n    setTimeout(loop, 1000);\n  }, []);\n\n  return now;\n}\n","import \"antd/dist/antd.css\";\nimport React from \"react\";\nimport { HashRouter as Router, Route, Routes } from \"react-router-dom\";\nimport { Provider as LightGodwokenProvider } from \"./contexts/LightGodwokenContext\";\nimport RequestWithdrawal from \"./views/RequestWithdrawal\";\nimport Withdrawal from \"./views/Withdrawal\";\n\nfunction App() {\n  return (\n    <LightGodwokenProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Withdrawal />}></Route>\n          <Route path=\"/request-withdrawal\" element={<RequestWithdrawal />}></Route>\n        </Routes>\n      </Router>\n    </LightGodwokenProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { config } from \"@ckb-lumos/lumos\";\n\nconfig.initializeConfig(config.predefined.AGGRON4);\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}